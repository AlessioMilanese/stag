#!/usr/bin/env python

# ============================================================================ #
# htc - A hierarchical taxonomic classifier for metagenomic sequences
#
# Authors: Alessio Milanese (milanese@embl.de),
#
# Type "htc" for usage help
#
#  LICENSE:
#    htc - A hierarchical taxonomic classifier for metagenomic sequences
#    Copyright (C) 2019  A. Milanese
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ============================================================================ #


from __future__ import division
import os
import sys
import argparse
import shlex
import shutil
import time
import subprocess
import glob
import tempfile
import errno

# add version of the tool ------------------------------------------------------
tool_version = "0.0"

# position of the script -------------------------------------------------------
path_htc = os.path.realpath(__file__)
path_array = path_htc.split("/")
relative_path = "/".join(path_array[0:-1])
relative_path = relative_path + "/"

# add /bin to the path ---------------------------------------------------------
try:
    if os.path.isdir(relative_path+'bin'):
        sys.path.insert(0, relative_path+'bin')
    else:
        sys.stderr.write("[E::main] Error: "+relative_path+"bin directory is missing.\n")
        sys.exit(1)
except:
    sys.stderr.write("[E::main] Error: "+relative_path+"bin directory is missing.\n")
    sys.exit(1)
try:
    import align as align
except:
    sys.stderr.write("[E::main] Error: fail to load the script: "+relative_path+"bin/align.py\n")
    sys.exit(1)
try:
    import create_db as create_db
except:
    sys.stderr.write("[E::main] Error: fail to load the script: "+relative_path+"bin/create_db.py\n")
    sys.exit(1)
try:
    import classify as classify
except:
    sys.stderr.write("[E::main] Error: fail to load the script: "+relative_path+"bin/classify.py\n")
    sys.exit(1)
try:
    import check_create_db_input_files as check_create_db_input_files
except:
    sys.stderr.write("[E::main] Error: fail to load the script: "+relative_path+"bin/check_create_db_input_files.py\n")
    sys.exit(1)

# function that checks if a file exists ----------------------------------------
def check_file_exists(file_name, isfasta = False):
    try:
        o = open(file_name,"r")
        # if fasta file, then check that it starts with ">"
        if isfasta:
            if not(o.readline().startswith(">")):
                sys.stderr.write("[E::main] Error. Not a fasta file: "+file_name+"\n")
                sys.stderr.write("          Fasta file is expected to start with '>'\n")
                o.close()
                sys.exit(1)
        o.close()
    except:
        sys.stderr.write("[E::main] Error: Cannot open file: "+file_name+"\n")
        sys.exit(1)

# function that checks if a file exists already, and give an error -------------
def check_file_doesnt_exists(file_name):
    if os.path.exists(file_name):
        sys.stderr.write("[E::main] Error: Output file exists already: "+file_name+"\n")
        sys.exit(1)

# ------------------------------------------------------------------------------
#       print the help informations
# ------------------------------------------------------------------------------
class CapitalisedHelpFormatter(argparse.HelpFormatter):
    def add_usage(self, usage, actions, groups, prefix=None):
        if prefix is None:
            prefix = ''
        return super(CapitalisedHelpFormatter, self).add_usage(usage, actions, groups, prefix)


def msg(name=None):
    str_msg = '''
\00
Program: htc - a hierarchical taxonomic classifier for metagenomic sequences
Version: '''+tool_version+'''

Usage: htc <command> [options]

Command:
 -- Main commands
      train       Train a classifier and create a database, to be used with htc
                  classify
      classify    Classify a sequence according to a database created with htc
                  train

 -- Secondary commands
      align       Align a sequence to a hmm or infernal model
      create_db   Create a database given the aligned sequences
      check_input Check the input for the train command

Type htc <command> to print the help for a specific command
        '''
    return str_msg

# ------------------------------------------------------------------------------
def print_menu_align():
    sys.stderr.write("\n")
    sys.stderr.write("Usage: htc align -i <fasta_seqs> -a <hmmfile> [options]\n\n")
    sys.stderr.write("  -i  FILE  sequences to be aligned (fasta format)\n")
    sys.stderr.write("  -p  FILE  protein sequences, corresponding to -i [None]\n")
    sys.stderr.write("  -a  FILE  hmmfile or cmfile to use as template for the alignment\n")
    sys.stderr.write("  -o  FILE  output file name [stdout]\n")
    sys.stderr.write("  -c        set if you are using a cmfile\n")
    sys.stderr.write("  -t  INT   number of threads [1]\n")
    sys.stderr.write("  -v  INT   verbose level: 1=error, 2=warning, 3=message, 4+=debugging [3]\n\n")
    sys.stderr.write("Note: if -p is provided, then the alignment will be done at the level\nof the proteins and then converted to gene alignment (from -i input).\nThe order of the sequences in -i and -p should be the same.\n\n")
# ------------------------------------------------------------------------------
def print_menu_create_db():
    sys.stderr.write("\n")
    sys.stderr.write("Usage: htc create_db -s <aligned_file> -x <taxonomy_file>\n")
    sys.stderr.write("                     -a <hmmfile> -o <output_DB> [options]\n\n")
    sys.stderr.write("  -s  FILE  file with 1-hot encoding MSA (result from htc align)\n")
    sys.stderr.write("  -a  FILE  hmmfile or cmfile to used as template for the alignment\n")
    sys.stderr.write("  -c        set if you are using a cmfile\n")
    sys.stderr.write("  -x  FILE  taxonomy file (tab separated)\n")
    sys.stderr.write("  -o  FILE  output file name (HDF5 format)\n")
    sys.stderr.write("  -f        force to rewrite output file\n")
    sys.stderr.write("  -v  INT   verbose level: 1=error, 2=warning, 3=message, 4+=debugging [3]\n\n")
# ------------------------------------------------------------------------------
def print_menu_classify():
    sys.stderr.write("\n")
    sys.stderr.write("Usage: htc classify -d <database> -i <fasta_seqs> [options]\n\n")
    sys.stderr.write("  -d  FILE  database created with create_db or train\n")
    sys.stderr.write("  -i  FILE  sequences to taxonomically annotate (fasta format)\n")
    sys.stderr.write("  -p  FILE  protein sequences, corresponding to -i [None]\n")
    sys.stderr.write("  -o  FILE  output file name [stdout]\n")
    sys.stderr.write("  -v  INT   verbose level: 1=error, 2=warning, 3=message, 4+=debugging [3]\n\n")
# ------------------------------------------------------------------------------
def print_menu_check_input():
    sys.stderr.write("\n")
    sys.stderr.write("Usage: htc check_input -i <fasta_seqs> -x <taxonomy_file>\n")
    sys.stderr.write("                       -a <hmmfile> [options]\n\n")
    sys.stderr.write("  -i  FILE  sequences to be aligned (fasta format)\n")
    sys.stderr.write("  -p  FILE  protein sequences, corresponding to -i [None]\n")
    sys.stderr.write("  -a  FILE  hmmfile or cmfile to used as template for the alignment\n")
    sys.stderr.write("  -c        set if you are using a cmfile\n")
    sys.stderr.write("  -x  FILE  taxonomy file (tab separated)\n")
    sys.stderr.write("  -v  INT   verbose level: 1=error, 2=warning, 3=message, 4+=debugging [3]\n\n")
# ------------------------------------------------------------------------------
def print_menu_train():
    sys.stderr.write("\n")
    sys.stderr.write("Usage: htc train -i <fasta_seqs> -x <taxonomy_file>\n")
    sys.stderr.write("                 -a <hmmfile> -o <output_DB> [options]\n\n")
    sys.stderr.write("  -i  FILE  sequences to be aligned (fasta format)\n")
    sys.stderr.write("  -p  FILE  protein sequences, corresponding to -i [None]\n")
    sys.stderr.write("  -a  FILE  hmmfile or cmfile to used as template for the alignment\n")
    sys.stderr.write("  -c        set if you are using a cmfile\n")
    sys.stderr.write("  -x  FILE  taxonomy file (tab separated)\n")
    sys.stderr.write("  -o  FILE  output file name (HDF5 format)\n")
    sys.stderr.write("  -S  FILE  save intermediate alignment file [None]\n")
    sys.stderr.write("  -f        force to rewrite output file\n")
    sys.stderr.write("  -t  INT   number of threads [1]\n")
    sys.stderr.write("  -v  INT   verbose level: 1=error, 2=warning, 3=message, 4+=debugging [3]\n\n")
    sys.stderr.write("Note: if -p is provided, then the alignment will be done at the level\nof the proteins and then converted to gene alignment (from -i input).\nThe order of the sequences in -i and -p should be the same.\n\n")

# ------------------------------------------------------------------------------
# MAIN
# ------------------------------------------------------------------------------
def main(argv=None):

    parser = argparse.ArgumentParser(usage=msg(), formatter_class=CapitalisedHelpFormatter,add_help=False)
    parser.add_argument('command', action="store", default=None, help='mode to use the mOTU tool',choices=['align','train','classify','create_db','check_input'])
    parser.add_argument('-o', action="store", dest='output', default=None, help='name of output file')
    parser.add_argument('-t', type=int, action="store", dest='threads', default=None, help='Number of threads to be used.')
    parser.add_argument('-v', action='store', type=int, default=None, dest='verbose', help='Verbose levels')
    parser.add_argument('-c', action='store_true', default=None, dest='use_cm_align', help='Set if you want to use cmalign isntead of hmmalign')
    parser.add_argument('-s', action="store", default=None,dest='aligned_sequences', help='sequences that needs to be aligned')
    parser.add_argument('-a', action="store", default=None,dest='template_al', help='alignment template')
    parser.add_argument('-x', action="store", default=None,dest='taxonomy', help='taxonomy file path')
    parser.add_argument('-f', action='store_true', default=None, dest='force_rewrite', help='Set if you want to rewrite the file, even if it exists')
    parser.add_argument('-i', action="store", dest='fasta_input', default=None, help='input fasta sequences')
    parser.add_argument('-p', action="store", dest='protein_fasta_input', default=None, help='input fasta sequences, in protein format. Corresponding to the -i sequences')
    parser.add_argument('-d', action="store", dest='database', default=None, help='file containing the database')
    parser.add_argument('-S', action="store", dest='intermediate_al', default=None, help='name of the file for the intermediate alignment')

    parser.add_argument('--version', action='version', version='%(prog)s {0} on python {1}'.format(tool_version, sys.version.split()[0]))

    args = parser.parse_args()

    # print menus --------------------------------------------------------------
    if (args.output is None) and (args.threads is None) and (args.verbose is None) and (args.use_cm_align is None):
        if (args.aligned_sequences is None) and (args.template_al is None) and (args.force_rewrite is None) and (args.taxonomy is None):
            if (args.fasta_input is None) and (args.database is None) and (args.protein_fasta_input is None) and (args.intermediate_al is None):
                if args.command == 'align': print_menu_align()
                if args.command == 'create_db': print_menu_create_db()
                if args.command == 'classify': print_menu_classify()
                if args.command == 'check_input': print_menu_check_input()
                if args.command == 'train': print_menu_train()
                sys.exit(1)


    # --------------------------------------------------------------------------
    # set defaults for the parameters
    # --------------------------------------------------------------------------
    if (args.threads is None): args.threads = 1
    if (args.verbose is None): args.verbose = 3
    if (args.use_cm_align is None): args.use_cm_align = False
    if (args.force_rewrite is None): args.force_rewrite = False

    if args.verbose < 1:
        sys.stderr.write("[E::main] Error: verbose level (-v) is less than 1\n")
        sys.exit(1)
    if args.threads < 1:
        sys.stderr.write("[E::main] Error: number of threads (-t) is less than 1\n")
        sys.exit(1)

    # --------------------------------------------------------------------------
    # ALIGN routine
    # --------------------------------------------------------------------------
    if args.command == 'align':
        # check that '-i' and '-a' have been provided
        if (args.fasta_input is None):
            sys.stderr.write("[E::main] Error: missing <seqfile> (-i)\n")
            sys.exit(1)
        if (args.template_al is None):
            sys.stderr.write("[E::main] Error: missing <hmmfile>/<cmfile> (-a)\n")
            sys.exit(1)
        # check that '-s' and '-a' are files
        check_file_exists(args.fasta_input,isfasta = True)
        check_file_exists(args.template_al,isfasta = False)

        # if -p is provided, then check that it is a fasta file
        if not(args.protein_fasta_input is None):
            check_file_exists(args.protein_fasta_input,isfasta = True)

        # call the function
        if args.output is None:
            for i in align.align_generator(args.fasta_input, args.protein_fasta_input, args.template_al, args.use_cm_align, args.threads, args.verbose, False):
                print(i)
        else:
            align.align_file(args.fasta_input, args.protein_fasta_input, args.template_al, args.use_cm_align, args.threads, args.verbose, args.output)

    # --------------------------------------------------------------------------
    # CREATE_DB routine
    # --------------------------------------------------------------------------
    if args.command == 'create_db':
        # check that '-s' has been provided (alignment produced by htc align)
        if (args.aligned_sequences is None):
            sys.stderr.write("[E::main] Error: missing <aligned_file> (-s)\n")
            sys.exit(1)
        # check that '-x' has been provided (taxonomy file)
        if (args.taxonomy is None):
            sys.stderr.write("[E::main] Error: missing <taxonomy_file> (-x)\n")
            sys.exit(1)
        # check that the hmm file is provided
        if (args.template_al is None):
            sys.stderr.write("[E::main] Error: missing <hmmfile>/<cmfile> (-a)\n")
            sys.exit(1)
        # check that '-s' and '-a' are files
        check_file_exists(args.aligned_sequences,isfasta = False)
        check_file_exists(args.taxonomy,isfasta = False)
        check_file_exists(args.template_al,isfasta = False)

        # check that output is set
        if args.output is None:
             sys.stderr.write("[E::main] Error: missing <output_DB> (-o)\n")
             sys.exit(1)
        if not args.force_rewrite:
            check_file_doesnt_exists(args.output)

        # call the function to create the database
        create_db.create_db(args.aligned_sequences, args.taxonomy, args.verbose, args.output, args.use_cm_align, args.template_al)

    # --------------------------------------------------------------------------
    # TRAIN routine
    # --------------------------------------------------------------------------
    if args.command == 'train':
        # FIRST: ALIGN ---------------------------------------------------------
        # check that '-i' and '-a' have been provided
        if (args.fasta_input is None):
            sys.stderr.write("[E::main] Error: missing <seqfile> (-i)\n")
            sys.exit(1)
        if (args.template_al is None):
            sys.stderr.write("[E::main] Error: missing <hmmfile>/<cmfile> (-a)\n")
            sys.exit(1)
        # check that '-s' and '-a' are files
        check_file_exists(args.fasta_input,isfasta = True)
        check_file_exists(args.template_al,isfasta = False)

        # if -p is provided, then check that it is a fasta file
        if not(args.protein_fasta_input is None):
            check_file_exists(args.protein_fasta_input,isfasta = True)

        # we create a temporary file that will contain the alignments
        al_file = tempfile.NamedTemporaryFile(delete=False, mode="w")
        os.chmod(al_file.name, 0o644)
        # call the function
        align.align_file(args.fasta_input, args.protein_fasta_input, args.template_al, args.use_cm_align, args.threads, args.verbose, al_file.name)

        # SECOND: CREATE_DB ----------------------------------------------------
        # check that '-x' has been provided (taxonomy file)
        if (args.taxonomy is None):
            sys.stderr.write("[E::main] Error: missing <taxonomy_file> (-x)\n")
            sys.exit(1)
        check_file_exists(args.taxonomy,isfasta = False)

        # check that output is set
        if args.output is None:
             sys.stderr.write("[E::main] Error: missing <output_DB> (-o)\n")
             sys.exit(1)
        if not args.force_rewrite:
            check_file_doesnt_exists(args.output)

        # call the function to create the database
        create_db.create_db(al_file.name, args.taxonomy, args.verbose, args.output, args.use_cm_align, args.template_al)

        # what to do with intermediate alignment -------------------------------
        if args.intermediate_al is None:
            # remove it
            os.remove(al_file.name)
        else:
            # save it
            shutil.move(al_file.name,args.intermediate_al)


    # --------------------------------------------------------------------------
    # CLASSIFY routine
    # --------------------------------------------------------------------------
    if args.command == 'classify':
        # check that '-i' has been provided (alignment produced by htc align)
        if (args.fasta_input is None):
            sys.stderr.write("[E::main] Error: missing <fasta_seqs> (-i)\n")
            sys.exit(1)
        # check that '-d' has been provided (taxonomy file)
        if (args.database is None):
            sys.stderr.write("[E::main] Error: missing <database> (-d)\n")
            sys.exit(1)
        # check that they are files
        check_file_exists(args.fasta_input,isfasta = True)
        check_file_exists(args.database,isfasta = False)
        # if -p is provided, then check that it is a fasta file
        if not(args.protein_fasta_input is None):
            check_file_exists(args.protein_fasta_input,isfasta = True)

        # call the function
        classify.classify(args.database, args.fasta_input, args.protein_fasta_input, args.verbose, args.threads, args.output)

    # --------------------------------------------------------------------------
    # CHECK_INPUT routine
    # --------------------------------------------------------------------------
    if args.command == 'check_input':
        if (args.fasta_input is None):
            sys.stderr.write("[E::main] Error: missing <fasta_seqs> (-i)\n")
            sys.exit(1)
        if (args.taxonomy is None):
            sys.stderr.write("[E::main] Error: missing <taxonomy_file> (-x)\n")
            sys.exit(1)
        if (args.template_al is None):
            sys.stderr.write("[E::main] Error: missing <hmmfile>/<cmfile> (-a)\n")
            sys.exit(1)
        check_create_db_input_files.check_input_files(args.fasta_input, args.protein_fasta_input, args.taxonomy, args.template_al, args.use_cm_align)


    return 0        # success

#-------------------------------- run main -------------------------------------
if __name__ == '__main__':
    status = main()
    sys.exit(status)
